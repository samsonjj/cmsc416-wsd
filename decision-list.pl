# Author: Jonathan Samson
# Date: 3/26/19
# Class: CMSC-416-001 VCU Spring 2019
# Project: Programming Assignment 4
# Title: decision-list.pl
#
#--------------------------------------------------------------------------
#   Problem Statement
#--------------------------------------------------------------------------
#
#   One of Natural Language Processing's (NLP's) essential challenges is word sense disambiguation (WSD). Similar spellins of
# a single word often have different meanings. This can be seen in the dictionary, where most words have multiple
# definitions. For example, run can be used to describe quick physical linear movement on foot, or the action of running
# for a position in an organization. WSD takes up the issue of automatically distinguishing the particular definition, or sense,
# of a word in text. This project applies WSD techniques to distinguise between senses given a training file and test file.
# 
#--------------------------------------------------------------------------
#   Usage Instructions and Example Input/Output
#--------------------------------------------------------------------------
#
# This is a perl program, so some version of perl must be installed before executing the file.
# See: https://www.perl.org/get.html
#
# To run the program, make sure you have a correclty training file and test file which match the format shown in the example
# after this section. Execute the program with those two files as arguments, as well as a third argument for the desired
# name of the log file, generated during program execution. The command should look as follows
#
#   perl decision-list.pl <training-file> <test-file> <log-file>
#
# During execution, the log file will be generated which details the list of tests (or decision list) which were used to
# disambiguate between word senses. Additionally, a set of answers will be printed to standard output.
#
# Below is a sample run of the program.
#
# [IN-COMMAND] perl decision-list.pl line-train.txt line-test.txt my-decision-list.txt > my-line-answers.txt
#
# [IN-TRAINFILE]
#   <corpus lang="en">
#   <lexelt item="line-n">
#   <instance id="line-n.w9_10:6830:">
#   <answer instance="line-n.w9_10:6830:" senseid="phone"/>
#   <context>
#   <s> The New York plan froze basic rates, offered no protection to Nynex against an economic downturn that sharply cut demand and didn't offer flexible pricing. </s> <@> <s> In contrast, the California economy is booming, with 4.5% access <head>line</head> growth in the past year. </s> 
#   </context>
#   </instance>
#   <instance id="line-n.w8_057:16550:">
#   <answer instance="line-n.w8_057:16550:" senseid="product"/>
#   <context>
#   <s> According to analysts, sales of PS/2 got off to a rocky start but have risen lately -- especially in Europe. </s> <@> <s> IBM wants to establish the <head>line</head> as the new standard in personal computing in Europe. </s> <@> <s> It introduced the line in April 1987 and has said it shipped nearly two million units by its first anniversary. </s> 
#   </context>
#   ...
#
# [IN-TESTFILE]
#   <corpus lang="en">
#   <lexelt item="line-n">
#   <instance id="line-n.w8_059:8174:">
#   <context>
#   <s> Advanced Micro Devices Inc., Sunnyvale, Calif., and Siemens AG of West Germany said they agreed to jointly develop, manufacture and market microchips for data communications and telecommunications with an emphasis on the integrated services digital network. </s> <@> </p> <@> <p> <@> <s> The integrated services digital network, or ISDN, is an international standard used to transmit voice, data, graphics and video images over telephone <head>lines</head> . </s> 
#   </context>
#   </instance>
#   <instance id="line-n.w7_098:12684:">
#   <context>
#   ...
#
# [IN-KEYFILE]
#   <answer instance="line-n.w8_059:8174:" senseid="phone"/>
#   <answer instance="line-n.w7_098:12684:" senseid="phone"/>
#   <answer instance="line-n.w8_106:13309:" senseid="phone"/>
#   <answer instance="line-n.w9_40:10187:" senseid="phone"/>
#   <answer instance="line-n.w9_16:217:" senseid="phone"/>
#   ...
#
# [OUT-STDOUT]
#   <answer instance="line-n.w8_059:8174:" senseid="phone"/>
#   <answer instance="line-n.w7_098:12684:" senseid="phone"/>
#   <answer instance="line-n.w8_106:13309:" senseid="phone"/>
#   <answer instance="line-n.w9_40:10187:" senseid="phone"/>
#   <answer instance="line-n.w9_16:217:" senseid="phone"/>
#   ...
#
# [OUT-LOGFILE]
#   LOG [generated by decision-list.pl]
#
#   Below is a description of each test (feature) of the decision-list which was used to disambiguate the test-file in the last run of decision-list.pl.
#   Any feature marked as 'BAG' was tested by searching the context for the given word.
#
#   [FEATURE]             (BAG) telephone
#   [CORRECT]             74
#   [TOTAL]               74
#   [LOG-LIKELIHOOD]      1
#   [SENSE]               phone
#   ...
#
#--------------------------------------------------------------------------
#   Algorithm
#--------------------------------------------------------------------------
#
# Below is a description of the structure of this program and its algorithm.
#
# 1) Parse training file.
#       * Use regex to gain the context as a string wihtout tags.
#       * Use regex to get the actual sense.
#       * Store (in the bagOfWords hash) the number of times each word appears with each sense.
# 2) Create feature vector. Run each test and record successes vs actual sense.
# 3) Rank each test based on frequency counts.
# 4) Parse test file.
# 5) Create feature vector. Run each test, create test vector, and check which one succeeded first based on ranking. Choose that sense.
# 6) If no test passes, return default.

use strict;
use warnings;
use feature 'say';

my %bagOfWords = ();

my $argCount = scalar @ARGV;
if($argCount < 3) {
    die "You must enter 3 arguments for train, test, and log file."
}

my $trainingFile = $ARGV[0];
my $testingFile = $ARGV[1];
my $logFile = $ARGV[2];

#################### (1) ####################
# Parse Training file.

# Open training file.
open(my $fhTrain, "<:encoding(UTF-8)", $trainingFile)
    or die "Could not open file '$trainingFile' $!";

# Assume each tag (Ex: "<instance>" is contained on the same line), so not like "<ins\ntance>".
# Assume each line only has one tag

my $currentInstance = "";

# Parse into each "instance".
while( my $line = <$fhTrain> ) {

    chomp $line;

    # Check for <instance> tag.
    if($line =~ /.*<\s*instance\s*(.*)>(.*)/) {
        $currentInstance = $2;
    }
    # Check for </instance> tag
    elsif ($line =~ /(.*)<\/\s*instance\s*(.*)>(.*)/ ) {
        $currentInstance = $currentInstance."\n".$1;

        # Process currentInstance
        my($correctSense) = $currentInstance =~ /<answer.*senseid="(.*)"/;

        my($context) = $currentInstance =~ /<context>(.*)<\/context>/s;
        $context =~ s/(<s>|<\/s>|<@>|<p>|<\/p>)//g;
        $context =~ s/([,\.!\?"])/ $1 /g;
        my @tokens = split(/\s+/, $context);

        # We now need to create a feature vector for this context.
        # We can do this with any set of features we want.
        # Most of the features will be searching the "bag of word" for certain key words.
        # Some other features will do different things.

        for my $word (@tokens) {
            if( !exists $bagOfWords{$word}{$correctSense} ) {
                $bagOfWords{$word}{$correctSense} = 1;
            }
            else {
                $bagOfWords{$word}{$correctSense}++;
            }
        }

        $currentInstance = "";
    }
    # Otherwise, we are inbetween instance tags, so add all text to current instance.
    else {
        $currentInstance = $currentInstance."\n".$line;
    }
}

my $defaultSense = "";
for my $word (sort keys %bagOfWords) {
    my $countSum = 0;
    my $maxKeyCount = 0;
    my $maxKey = "";
    for my $sense (sort keys %{ $bagOfWords{$word} }) {
        $countSum += $bagOfWords{$word}{$sense};
        # print $bagOfWords{$word}{$sense};
        if( $bagOfWords{$word}{$sense} > $maxKeyCount ) {
            $maxKeyCount = $bagOfWords{$word}{$sense};
            $maxKey = $sense;
        }
        $defaultSense = $sense;
    }
    $bagOfWords{$word}{"maxKey"} = $maxKey;
    $bagOfWords{$word}{"correctCount"} = $maxKeyCount;
    $bagOfWords{$word}{"totalCount"} = $countSum;
}

# my @rankedWords = sort {($bagOfWords{$b}{"correctCount"} / $bagOfWords{$b}{"totalCount"})
#                     cmp ($bagOfWords{$a}{"correctCount"} / $bagOfWords{$a}{"totalCount"})}
#                     sort keys %bagOfWords;

my @rankedWords = sort rankedSort (sort keys %bagOfWords);

my $rankedWordsLength = scalar @rankedWords;
for( my $i=0; $i<$rankedWordsLength; $i++ ) {
    my $word = $rankedWords[$i];
    my $correct = $bagOfWords{$word}{"correctCount"};
    my $total = $bagOfWords{$word}{"totalCount"};
    my $max = $bagOfWords{$word}{"maxKey"};
    if ($total < 5) {
        splice @rankedWords, $i, 1;
        $i--;
    }
    elsif ($correct / $total < .60) {
        splice @rankedWords, $i, 1;
        $i--;
    }
    $rankedWordsLength = scalar @rankedWords;
}

for( my $i=0; $i<$rankedWordsLength; $i++ ) {
    my $word = $rankedWords[$i];
    my $correct = $bagOfWords{$word}{"correctCount"};
    my $total = $bagOfWords{$word}{"totalCount"};
    my $max = $bagOfWords{$word}{"maxKey"};
    # print "$word ($correct $total $max)\n";
}

# Open log file.
open(my $fhLog, ">:encoding(UTF-8)", $logFile)
    or die "Could not open file '$logFile' $!"; 

# Print our newly defined decision list to the log file.
# Include description of feature, log-likelihood score, and predicted sense.
print $fhLog "LOG [generated by decision-list.pl]\n\n";
print $fhLog "Below is a description of each test (feature) of the decision-list which was used to disambiguate the test-file in the last run of decision-list.pl.\n";
print $fhLog "Any feature marked as 'BAG' was tested by searching the context (bag of words) for the given word.\n\n";

for( my $i=0; $i<$rankedWordsLength; $i++ ) {
    print $fhLog "[FEATURE]             (BAG) $rankedWords[$i]\n";
    my $correct = $bagOfWords{$rankedWords[$i]}{"correctCount"};
    my $total = $bagOfWords{$rankedWords[$i]}{"totalCount"};
    print $fhLog "[CORRECT]             $correct\n";
    print $fhLog "[TOTAL]               $total\n";
    my $logLikelihood = 1;
    if( $total != $correct) {
        $logLikelihood = abs(log($correct / ($total - $correct)));
    }
    print $fhLog "[LOG-LIKELIHOOD]      $logLikelihood\n";
    my $sense = $bagOfWords{$rankedWords[$i]}{"maxKey"};
    print $fhLog "[SENSE]               $sense\n\n";
}


# my $mostCommonTag = "";
# my $mostFrequentTagBaselineAccuracy = 0;
# if( $totalPhone > $totalProduct ) {
#     $mostCommonTag = "phone";
#     $mostFrequentTagBaselineAccuracy = $totalPhone / ($totalPhone + $totalProduct);
# }
# else {
#     $mostCommonTag = "product";
#     $mostFrequentTagBaselineAccuracy = $totalProduct / ($totalPhone + $totalProduct);
# }
# print $fhLog "\n"."Baseline of most frequent tag in train file is $mostCommonTag with probability $mostFrequentTagBaselineAccuracy\n"; 

# 

#################### (idk) ####################
# Tag the test file.

open(my $fhTest, "<:encoding(UTF-8)", $testingFile)
    or die "Could not open file '$testingFile' $!";

my $instanceId = "";
$currentInstance = "";

# Parse into each "instance".
while( my $line = <$fhTest> ) {

    chomp $line;

    # Check for <instance> tag.
    if($line =~ /.*<\s*instance\s*(.*)>(.*)/) {
        $currentInstance = $2;
        ($instanceId) = $line =~ /<instance.*id="(.*)"/;
    }
    # Check for </instance> tag
    elsif ($line =~ /(.*)<\/\s*instance\s*(.*)>(.*)/ ) {
        $currentInstance = $currentInstance."\n".$1;

        # Process currentInstance
        my($context) = $currentInstance =~ /<context>(.*)<\/context>/s;
        my $contextBackup = $context;
        $context =~ s/(<s>|<\/s>|<@>|<p>|<\/p>)//g;
        $context =~ s/([,\.!\?])/ $1 /g;
        my @tokens = split(/\s+/, $context);

        # We now need to create a feature vector for this context.
        # We can do this with any set of features we want.
        # Most of the features will be searching the "bag of word" for certain key words.
        # Some other features will do different things.

        print "<answer instance=\"$instanceId\" senseid=\"";

        my $senseFound = 0;
        for my $word (@rankedWords) {
            if( $context =~ /\Q$word/ ) {
                print $bagOfWords{$word}{"maxKey"};
                $senseFound = 1;
                last;
            }
        }
        $defaultSense = "phone";
        if( $senseFound == 0 ) {
            print $defaultSense;
        }
        print "\"/>\n";
        $currentInstance = "";
    }
    # Otherwise, we are inbetween instance tags, so add all text to current instance.
    else {
        $currentInstance = $currentInstance."\n".$line;
    }
}

sub rankedSort {
    if( ($bagOfWords{$b}{"correctCount"} / $bagOfWords{$b}{"totalCount"})
    == ($bagOfWords{$a}{"correctCount"} / $bagOfWords{$a}{"totalCount"}) ) {
        return $bagOfWords{$b}{"correctCount"} - $bagOfWords{$a}{"correctCount"};
    }
    else {
        return ($bagOfWords{$b}{"correctCount"} / $bagOfWords{$b}{"totalCount"})
            cmp ($bagOfWords{$a}{"correctCount"} / $bagOfWords{$a}{"totalCount"}); 
    }
}